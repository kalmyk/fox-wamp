# demo easy start

## resource-lock.supervisord.ini
three clients that lock resource for the 5 second each, so the next able to lock the resource after the previous release it

- to start:
```shell
$ supervisord -c ./resource-lock.supervisord.ini
```

## leaderless.supervisord.ini
leaderless queue work

- to start:
```shell
$ supervisord -c ./leaderless.supervisord.ini


```
# blueprint
advanceId {segment, offset}
    advanceId.segment - nearly random string value
    advanceId.offset - 

entry
    When message arrived, unique advance-id is created. With that destination partition id is generated by round-robin. The message and all messages comming after that are signed by that advance-id and sequence number. The begin-advance-segment is sent to all sync hosts and ndb-storages. Messages bodies are sent to all corresponding destination storage hosts with keep-advance-history message.

    at fillup-advance-segment message the entry collects votes from storage copies. when fillup-advance-segment elected the advance-segment is completed and advance-segment-over message is sent to destination storage host. New advance-segment will be generated at the next inbound message.

    advance-segment-resolved message arrived when advance-id become permanent identifier. At that time entry able to send ACK message for messages with permanent id.

ndb-storage
    at begin-advance-segment arrived, the fillup-advance-segment message is generated immidiatelly to terminate segment at entry. arriving inbound messages in keep-advance-history are stored temporary with advance-id marker. when advance-segment-resolved arrived the temporary storage is moved to permanent.

sync
    the sync cluster is responsible to transform nearly random advance-id to monotonic id.

